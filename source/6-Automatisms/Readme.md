Title: Automatisms
page_order: 6

## Automatisms 
[is this the best title? - all others are two words as camel text - squashed together. for consistency we shoukd do the same. and what is it really about? maybe MachineOperations or AutoGeneration ??/g] [how about Auto Generator? /w]
## setup() 

Following the previous discussion of abstraction concerning objects, this chapter introduces the idea of the abstract machine. By this we refer to the creation of rules generated by a self-operating machine, widely known as an abstract machine or Turing machine. It was mathematician and computer scientist Alan Turing who first described this kind of machine automation in his infamous article "On Computable Numbers, with an Application to the Entscheidungsproblem", published in 1936.[^Turing] He uses the term *universal computing machine* to theorize a model that describes how a machine "can be used to computate any computatable sequence",[^Turing1] understood as how a machine operates and follows a predetermined sequence of instructions that process input and produce output results. 

More specifically, the Turing machine is capable of six types of fundamental operations (at that time there wasn't a thing called a computer) — including read, write, move left, move right, change state and halt/stop. Turing suggested these operations could be performed via running an endless tape (like memory/storage in a modern computer) with instructions on what symbols to read and write, as well as how to move. These instructions are fundamental to the Turing machine,[^visualization] but also modern computing, that has the capability to compute tasks in numbers and automate processes. These instructions in turn pervade digital culture and seem to underwrite the wider processes of production, consumption and distribution of contemporary (informational) capitalism.    

![turing](ch6_1.jpg)

*Figure 6.1: An illustration of the Turing Machine*

This chapter thus explores how instructions are fundamental elements of adaptive and autonomous processes. Although the previous chapter was also about rules in terms of how objects (e.g. tofu and beer) appear and could be interacted with, this chapter will be more about how rules are performed and how they might produce unexpected results. 

Focusing on rules and instructions are not only something programmers do, but also something you do when following a knitting pattern or recipe (as we will see with the preparation of tofu later). Artists have also produced artworks that are instruction-based as in the case of the Fluxus and the Conceptual Art movements of the 1960s and 1970s that set out to challenge art's object-ness, and its "dematerialsation".[^Lippard] There are many examples of commentators making the connections between these instruction-based works and computational art,[^Cox] for instance the survey exhibition *Programmed: Rules, Codes, and Choreographies in Art, 1965-2018*,[^exhibition], organized by Christiane Paul at the Whitney Museum of American Art (2018-19), explored how instruction-based practices have both responded to and been shaped by technologies. The work of artist Sol Le Witt is one of the key examples here, demonstrating how a concept is based on a set of instructions but the outcome might be different depending on the specific context and how the instructions are executed by other people. LeWitt explains: "The idea becomes a machine that makes the art".[^LeWitt] For example, the work *Wall Drawing #289* consists of three simple instructions but without specific detail on the angles and length of the lines:

1. twenty-four lines from the center 
2. Twelve lines from the midpoint of each of the sides
3. Twelve lines from each corner 

![drawing2](ch6_2.jpg)
*Figure 6.2: Sol LeWitt, Wall drawing #289, 1976* [if copyright a problem then use a casey reas example maybe /g]

It becomes clear how conceptual practices combine idea and action in parallel to how performance works with scores and scripts, and in turn how programs work with instructions and their execution. LeWitt's work lends itself well to computation, and this was taken up by Casy Reas using Processing to render LeWitt's wall drawings from their instructions and thus to explore the parallels of interpretation and process in each case.[^Reas] Despite the LeWitt quote above, in his accompanying text he makes an important distinction in that LeWitt's programs are to be executed and interpreted by people rather than machines a such. Yet it is the close connection and overlaps that interests Reas — also underlying the development of the Processing as a "software sketchbook" — wanting programming to be as immediate and fluid as the practice of drawing. 
 
[I would be tempted to drop this example - good as it is, and a woman - and the next section follows Reas well /g] Another example is Joan Truckenbrod who has shown her work *Coded Algorithmic Drawing (#9)* in the same show. The piece with a number of squares of variations in size and angle was coded with the programming language Fortran in the 1970s, simulating moving substance in natural phenomena.[^joan] [w: add a 2 lines on simulation - fractal, flocking behaviors, the nature/technical/culture blur /w]
![drawing3](ch6_3.png)

*Figure 6.3: Joan Truckenbrod, Coded Algorithmic Drawing, 1975* ]

This kind of approach is important not only because of offering a different way to draw and author works by machines based on mathematical logic, but also to provide a sense of machinic creativity that — as in the previous chapter — questions the centrality of human (and more often than not, male) agency. In this chapter we aim to explore more complex combinations that combine people and machines (if not animals, as our upcoming example is an ant). 

If we were to draw an ellipse in white color at the x and y coordinate 100 and 120, there is a direct correspondance to the instruction. The outcome is predictable as the instruction is followed unambiguosuly but this need not be the case as certain kinds of instructions or combinations of instructions can generate unpredictable results. This *generative* quality throws into question the extent of control and autonomy over the creative process, made clear in the following definition of generative art:[^galanter]
> Generative art refers to any art practice where artists use a system, such as a set of natural languages, rules, a computer program, a machine, or other procedural invention, which is set into motion with some degree of autonomy contributing to or resulting in a completed work of art.

As we can see this definition does not limit itself to the use of computers and this is important to bear in mind as we proceed to focus on our sample code. In the following two examples we explore rule-based programs that unfold some of these issues of autonomy, but as with previous ones we are interested in the wider implications. 

## start()

The first program is called *10 PRINT* based on one line of program code `10 PRINT CHR$(205.5+RND(1));: GOTO 10`, written in the BASIC programming language and executed on a Commodore 64 home computer. It generates an endless pattern on the screen. It is printed in the 1982 *Commodore 64 User's Guide* and later published on the web. This line of code has become an important example in the field of software studies to demonstrate the history and culture of creative computing.[^10print] *10 PRINT* in `p5.js` below is used to help us become familiar with rules and its creative potential to demonstrate some degree of autonomy within a system.  

The second program is entitled *Langton's Ant* (1986), a two-dimensional universal Turing machine invented in 1986 by the computer scentist Christopher Langton who is considered to be one of the founders of field of Artificial life.[^Langton] The core difference with *10 PRINT* is the way that complex emergent behavior is generated with only a simple set of rules. 

## Exercise in class (10 PRINT)

![drawing4](ch6_4.png)

*Figure 6.4: 10 PRINT in p5.js*

[RUNME](https://gitlab.com/siusoon/Aesthetic_Programming_Book/blob/master/sample_codes/p5_SampleCode/ch6_Automatisms/index.html)

1. Read the source code of *10 PRINT* then copy it and run it on your own computer.

```javascript
let x = 0;
let y = 0;
let spacing = 10;

function setup() {
  createCanvas(windowWidth,windowHeight);
  background(0);
}

function draw() {
  stroke(255);
  if (random(1) <0.5) {  
    line(x,y,x+spacing,y+spacing);
  } else {
    line(x,y+spacing,x+spacing,y);
  }
  x+=10;
  if (x > width) {
    x = 0;
    y += spacing;

  }
}
```

2. Discuss the following rules of *10 PRINT* and map them to the related lines of code:
    - Throw a dice randomly and half of the time print a backward slash
    - The other half of the time will print a forward slash

3. Discuss the use and the role of randomness in *10 PRINT* and in the arts, literature, and games? What is randomness to a computer?[^Haahr]  

4. Try to modify the existing rules, for example: 
    - Can we have other outputs than just the backward and forward slash?
    - Can we chnage the size and color of the slashes? 

5. *10 PRINT* has been appropriated by many artists, designers and students. Take a look at some of the different possibilities for [*10 PRINT*](https://twitter.com/search?q=%2310print&src=typd) that are documented on Twitter. Your in-class task is to create a sketch with a clear set of rules and that operates as a modified version of *10 PRINT*.  

## Randomness 
[w: add randomness here /w]

## Langton's Ant 

*Langton's Ant* is a classical mathematical game that simulates the molecular logic of a living ant. The simulation of the cell's state is inspired by the classical Turing machine that can perform computational tasks with the manipulation of symbols on a strip of tape according to a set of rules. 

[more on this in the context of generative art and introduce cellular automaton - game of life /g]

This section presents sample code to simulate the cell states, presenting in a two-dimensional grid system in either the color black or white. Based on simple rules, an ant is considered to be the input source that will change the state of the cell by moving in four directions. The ant will gradually turn the grid into a more complex system that exhibits emergent behavior over time.

![drawing5](ch6_5.gif)

*Figure 6.5: Langton's Ant - Initial steps*

With the initial direction of an ant pointed upwards (i.e. North position), figure 6.5 shows the initial 33 steps of  *Langton's Ant* in following the two general rules below:

1. If the ant is at a white cell, it turns right 90° and changes to a black cell then moves forward one unit.
2. If the ant is at a black cell, it turns left 90° and changes to a white cell then moves forward one unit. 

At the beginning, the canvas displays only a grid system and all the individual cells are set in white color. The ant has  four possible directions — UP, RIGHT, DOWN, LEFT — and can turn 90° either left or right subject to the color of the cell. The ant's head is pointing in an UPWARD position at the start, and is located in the middle of the white grid. It then follows rule 1 above to rotate the head direction from UP to RIGHT, then it also changes the white cell to the black and moves forward one unit (pointing to the right as per the new head direction). Then the second step is to follow rule 1 again because the new cell is still white. The ant's head direction will turn right 90° and point from RIGHT to DOWN, and then changes the white cell to black and the ant moves forward one unit. Then the third and forth steps are similar to the previous ones until the ant meets a cell which is black, which is started in step 5. At this point, the ant will follow rule 2 instead to change back cell's color back to white and then turns left 90° instead of the right. The complexity builds. 

![drawing6](ch6_6.gif)

*Figure 6.6: Langton's Ant - Process*

Figure 6.6 shows how the ant starts building the emergent 'highway' pattern[^Moreira] after the first few hundred moves with simple symmetricial patterns. It is then followed by an additional 9000 steps[^Steps] with the seemingly random steps at the center. The highway pattern repeats indefinitely until most of cells are reconfigured, leading to something that is similar to Figure 6.7 at which point the ant is still constantly moving and changing the color of the cells.

![drawing7](ch6_7.png)

*Figure 6.7: Langton's Ant - A snapshot of emergence*

[RUNME](https://gitlab.com/siusoon/Aesthetic_Programming_Book/blob/master/sample_codes/p5_SampleCode/ch6_Automatisms/sketch_6_1/index.html)

## Source code (Langton's Ant)
```javascript
let grid_space = 5; //e.g. 4, 5, 10 need to be dividable as an integer by the width and height of the canvas
let grid =[]; //on/off state
let cols, rows; //for drawing the grid purpose
let xPos, yPos; //current position in terms of rows and cols, not actual pixel
let dir; //current direction of the ant
const antUP = 0;
const antRIGHT = 1;
const antDOWN = 2;
const antLEFT = 3;
let offColor;
let onColor;

function setup() {
  createCanvas(1000,700);
  offColor = color(255); //setting offcolor
  onColor = color(0); //setting onColor
  background(offColor);
  grid = drawGrid();
  xPos = floor(cols/2); //initial x position and make sure it is an integer in the grid array
  yPos = floor(rows/2); //initial y position and make sure it is an integer in the grid array
  dir = antUP; //initial direction
  frameRate(20);
}

function draw() {
  for (let n = 0; n < 100; n++) { //for running faster per frame, try changing the n value
   checkEdges();
   let state = grid[xPos][yPos]; //check the current cell's state
   if (state == 0) { //rule 1
    dir++; // turn right 90°
    grid[xPos][yPos] = 1; //change the currect cell's state to 'on'
    fill(onColor); //subsequent color change
    if (dir > antLEFT) {
      dir = antUP; //reset the counter
    }
   }else{ //rule 2
    dir--; //turn left 90°
    grid[xPos][yPos] = 0; //change the current cell's state to 'off'
    fill(offColor); //subsequent color change
    if (dir < antUP) {
      dir = antLEFT; //reset the counter
    }
   }
   rect(xPos*grid_space, yPos*grid_space, grid_space, grid_space);
   nextMove();
  }
}
function drawGrid() {
  cols = width/grid_space;
  rows = height/grid_space;
  let arr = new Array(cols);
  for (let i=0; i < cols; i++) { //no of cols
    arr[i] = new Array(rows); //2D array
    for (let j=0; j < rows; j++){ //no of rows
      let x = i * grid_space; //actual x coordinate
      let y = j * grid_space; //actual y coordinate
      stroke(0);
      strokeWeight(1);
      noFill();
      rect(x, y, grid_space, grid_space);
      arr[i][j] = 0; //assign each cell with the off state + color
    }
  }
  return arr; //a function with a return value of the cell's status
}

function nextMove () { //check which direction to go next and set the new current direction
  if (dir == antUP) {
    yPos--;
  } else if (dir == antRIGHT) {
    xPos++;
  } else if (dir == antDOWN) {
    yPos++;
  } else if (dir == antLEFT) {
    xPos--;
  }
}

function checkEdges() { //check width and height boundary
  if (xPos > cols-1) { //reach the right edge
    xPos = 0; //go back to the left
  } else if (xPos < 0) { //reach the left edge
    xPos = cols-1; //go to the right edge
  }
  if (yPos > rows-1) { //reach the bottom edge
    yPos = 0; //go back to the top
  } else if (yPos < 0) { //reach the top edge
    yPos = rows-1; //go to the bottom
  }
}

```

## Reading Langton's Ant

Based on the above example, there are three areas can help in slowing down or zooming in on the program. 
1. `let grid_space = 5;`: You can change the value to 10 then you are able to see it at a larger size.   
2. `frameRate(20);`: Lower the frameRate value can help slow down the program
3.  `draw()`: This function contains a for-loop where n is the number of steps of the ant so if desired you can reduce the `n < 100` to `n < 1` in the line `for (let n = 0; n < 100; n++) {` thus instructing the program to only process n steps per frame.

Intead of going through the code line by line, this next part is more to show what each function does. 

- `function setup()`: This is more to setup the canvas size, initiate the ant's head direction, frameRate, color and to prepare drawing the background grid structure. 

- `function drawGrid()`: To divide the canvas into a grid structure with lines.

- `function draw()`: This is the main function to check against the two rules of Langton's Ant and change the color of cells. 

- `function nextMove()`: The four directions are structured in a number format so that the variable `dir++` can be used for incrementing or decrementing the ant's direction. Each different direction of *UP, RIGHT, DOWN, LEFT* corresponds to moving forward in either horizontal (xPos) or vertical (yPos) steps on the canvas. 

- `function checkEdges()`: This function is to check if the ant moves out of the four edges, then it will continue at the other end. 

Technically speaking, there is no new syntax here as the 2-dimensional arrays have already been covered briefly in Chapter 4 - Data Capture. However, there is the new use of 2-dimensional arrays and nested for-loops in the sample code. 

## 2-dimensional Arrays & Nested for-loops

Daniel Shiffman has created a tutorial (both in written[^shiffman1] and video[^shiffman2] formats) to discuss how a 2-dimensional array is essentially an array of other arrays. He also suggests that it is useful to think about 2-dimensional arrays with a grid structure which aligns nicely with the background of *Langton's Ant* designed as a grid in two dimensions with both columns and rows. Since we need to identify the state of each cell, we need to know the exact x and y position of each cell. 

Let's examine the source code again for the grid drawing: 

```javascript
function drawGrid() {
  cols = width/grid_space;
  rows = height/grid_space;
  let arr = new Array(cols);
  for (let i=0; i < cols; i++) { //no of cols
    arr[i] = new Array(rows); //2D array
    for (let j=0; j < rows; j++){ //no of rows
      let x = i * grid_space; //actual x coordinate
      let y = j * grid_space; //actual y coordinate
      stroke(0);
      strokeWeight(1);
      noFill();
      rect(x, y, grid_space, grid_space);
      arr[i][j] = 0;  //assign each cell with the off color and link to individual cells
    }
  }
  return arr; //a function with a return value
}
```

To create an array, we use the syntax `let arr = new Array(cols);` and this line indicates the grid in columns and the length of the array is the number of columns. Since we also need to cater for the number of rows, we create another array out of each existing array in the column with the line `arr[i] = new Array(rows);`. This syntax is put under a for-loop to loop through each of the columns but then with the addition of number of rows (which is derived from the canvas's height). Therefore, 2-dimensional arrays are visualized in this way: `arr[][]`. 

In order to know the exact x and y coordinates of each cell within a grid structure, it depends on which columns and which rows you are pointing at with the formular `x = i * grid_space;` and `y= j * grid_space;` respectively. By using two nested for-loops, the program will loop through each column and each row (under the same column) until the program runs to the last column. Ultimately, we are able to get the x and y coordinates with the syntax `array[i][j]`, which is applied to columns (with the variable i) and rows (with the variable j).

Therefore, each divided cell is presented in the structure of a 2-dimensional array. It depends on the width and height of the canvas and how you want to distribute the space. Each cell represents a possibility that an ant can move as a unit and demonstrate an on or off state that is represented in the color black or white. 

## Exercise in class

1. Give yourself sometime to read and tinker with the code, as well as to observe the different stages of *Langton's Ant*. 

2. Right now the *Langton's Ant* program is more about representing the world of an ant through abstraction, such as limited cell color, as well as only being able to move in four directions and turn 90°. Rethink the rules that have been implemented. Can you try changing the existing rules or adding new rules so that the ant behaves differently? (Recall what you have changed in the previous exercise on *10 PRINT*.) 

3. It is clear that in simulating and abstracting living systems — such as the complex behaviour of insects — there is a focus on emergent and generative process over end-result. In terms of creative process this allows us to think about how rules and instructions can produce complexity and other forms of control and agency. 
Let's discuss the following questions:
- Can you think of and describe other systems and processes that exhibit emergent behaviour? 
- How would you understand autonomy and agency in this context?[^Watz] 
- To what extent do you consider the machine to be an active agent in generative and autonomous systems? What are the implications for wider culture?

## While()

We already have discussed the idea of unleashing potential in the previous chapter and it would seem that generative systems promise something similar as a means to change an existing system. The allusion to living systems is made clear in *Game of Life* —  developed by the mathematician Jon Conway in 1970 — a further example of a Turing machine and how an evolutionary process is determined by its initial state, requiring no further input, and producing emergent forms. Langton's Ant — our earlier example — is also based on these principles in which there is a regular grid of cells (cellular automata), each in one of a finite number of states, such as on and off, or alive and dead in this case. We have already explored the reductive logic of this somewhat in this chapter but this example is also troubling as it addresses life and death in terms of populations and neighbourhoods, as if part of a social cleansing programme (or dystopian smart city[^smart]). 

Every cell interacts with other cells that are directly adjacent, and the following transitions occur:
> Any live cell with fewer than two live neighbours dies, as if by underpopulation.
> Any live cell with two or three live neighbours lives on to the next generation.
> Any live cell with more than three live neighbours dies, as if by overpopulation.
> Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.

Maybe this is simply a poor abstraction. That said, there is an alternative political potential here in the way an adaptive complex organism can assemble itself *bottom-up*, without a central *top-down* command and control mechanism.[^emergence] This is referred to a *revolutionary* moment where it becomes impossible to predict the direction change will take, and whether it will fall into a higher level of order or disintegrate into chaos. We return to ants again here as the study of ant colonies reveal that there is no discernible hierarchy at work, and although humans have named the ants in provocative terms, the 'queen' is not an authority figure at all but an egg-laying and the workers operate in a cooperative rather than feudal structure (although, as an aside, it should be pointed out that the workers are female, but the gender politics of ants is outside our scope). To be more precise, and according to complexity theory, all systems contain subsystems that are continually fluctuating. It is possible that one or more fluctuations, as a result of feedback, may change the preexisting organisation of the system. One of the properties of the evolution of a complex system is that multiple interacting elements in a system cannot be governed and the collective behaviour cannot be predicted, as Ilya Prigogine and Isabelle Stengers explain in *Order Out of Chaos*:

> "A society defined entirely in terms of a functional model would correspond to the Aristotelian idea of natural hierarchy and order. Each official would perform the duties for which he [sic] has been appointed. These duties would translate at each level the different aspects of the organization of the society as a whole. The king gives orders to the architect, the architect to the contractor, the contractor to the worker. On the contrary, termites and other social insects seem to approach the 'statistical' model. As we have seen, there seems to be no mastermind behind the construction of the termites' nest, when interactions among individuals produce certain types of collective behaviour in some circumstances, but none of these interactions refer to any global task, being all purely local."[^chaos] 

If we look to a history of computing for an understanding of emergent behaviour, we might cite Turing's article of 1952 "The Chemical Basis of Morphogenesis" that described the way in which natural patterns naturally arise from a homogeneous, uniform state.[^morpho] This idea of morphogenesis is something that the political theorist and activist Franco 'Bifo' Berardi has utilised to describe social and political mutation, or when new political form emerges and takes shape, a "morphogenetic modeling of the living operated by the habitat with which it is required to interact" as he puts it.[^Bifo] His concern is to better understand the conditions in which the mutations take place, and how cognitive and imaginative automatisms might be repurposed for collective action. 

Automation has not only replaced physical and cognitive labour with algorithmic procedures but also for Berardi automatisms are an attack on "general intellect". EXPLAIN

Automation is taking the place of political decision, and the word “governance” refers essentially to this automation of data interpretation and decision: it implies the end of politics, democracy, and conscious decision-making, and the establishment of an automatic chain of logical procedures intended to replace conscious voluntary choices.

As some theorists have argued (e.g., Kevin Kelly in his Out of Control: The New Biology of Machines, Social Systems, and the Economic World), the social organism is going to be transformed into a swarm, a collective organism composed of many individual bodies whose brains follow rules embedded in the nervous system of each individual. The individuals who comprise a swarm act in a coordinated way even if no centralized structure of control dictates how the individuals should behave. 

Cognitive automatisms act as embedded rules which lead to the emergence of a form of intelligent behavior that is not consciously performed by the individuals who take part in the swarm.
//////////

MORE ON BIFO

We are left with the idea of autonomy...
- more on automatism and production, and autonomy as power to determine life
+++++++++++

But more relevant for our purpose is another example, the generative *love-letters* that appeared on the notice board of Manchester University’s Computer Department shortly after in 1953. These computer-generated declarations were produced by a program written by the programmer Christopher Strachey using the built-in random generator of the Manchester University Computer (the Ferranti Mark I), the earliest programmable computer. Regarded by some as the first example of a digital artwork,[^Noah] and by Jacob Gaboury as a critique of heteronormative love,[^Gaboury] as Strachey like Turing was queer. Moreover this is arguably more than a longing for same sex love but more human-machine love.

Artist David Link has since reconstructed a functional replica of both the hardware and the original program, following meticulous research on the functional aspects.[^loveletters] The main program is relatively simple, using loops and a random variable to follow the sentence structure: "You are my — Adjective — Substantive,” and “My — [Adjective] — Substantive — [Adverb] — Verb — Your — [Adjective] — Substantive." Some words are fixed and some optional, indicated by the square brackets. The program selects from the list of options—adjectives, adverbs, and verbs — and loops are configured to avoid repetition. The software could generate over 318 billion variations. In terms of effect, the dialogic structure is important too in setting up an exchange between *Me* (the program writer) and *You* (the human reader), such that you feel addressed directly. The resultant declarations suggest a surprising tenderness of expression that runs contrary to what we consider the standard functional outcomes of computational procedures. Here is a sample output:

> DEAR DARLING
> YOU ARE MY BEAUTIFUL RAPTURE. MY INFATUATION BEAUTIFULLY CLINGS TO YOUR ADORABLE LUST. MY INFATUATION LUSTS FOR YOUR WISH. MY AMBITION CURIOUSLY LIKES YOUR LOVE. YOU ARE MY DEAR EAGERNESS.
> YOURS WISTFULLY
> M. U. C.

This is far from a reductionist view of love, and perhaps the challenge for those making programs is to generate queer recombinant forms. 

## Mini_Exercise[6]: A generative program

**Objectives:**
- To implement a rule-based generative program from scratch.
- To strengthen the computational use of loops and conditional statements in a program.
- To reflect upon the concept of automatism conceptually and practically.

**To get some additional inspiration here:**
- [{Software} Structure #003 A by Casey Reas](https://whitney.org/exhibitions/programmed?section=1&subsection=6#exhibition-artworks)
- [Generative Design - sketches](http://www.generative-gestaltung.de/2/), [soure code](https://github.com/generative-design/Code-Package-p5.js)
- [GenArt (with source code)](https://github.com/JosephFiola/GenArt) by JosephFiola, see ch.1-4
- [Open Processing with the search keyword 'generative'](https://www.openprocessing.org/browse/?q=generative&time=anytime&type=all#)
- [John Conway's Game of Life](http://web.stanford.edu/~cdebs/GameOfLife/)
- [The recode project](http://recodeproject.com/) or https://web.archive.org/web/20181227225001/http://www.recodeproject.com/
- [WUOUS by Anders Visti and Tobias Stenberg](https://andersvisti.dk/work/wuos-2019) (with an implementation of the Langton's Ant)

**Tasks (RUNME):**
1. Start with a blank paper. Think of at least two simple rules that you want to implement in a generative program. (You may take reference from Langton's ant (1986) and The Game of Life (1970))
2. Based on the rules that you set in step 1, then design a generative program that utilizes at least one for-loop/while-loop and one conditional statement but without any direct interactivity. Just let the program run and emerges automatically. (You may also consider to use `noise()` and `random()` syntax if that helps)

**Questions to think about as README:**
- What are the rules in your generative program and describe how your program performs over time and how are the running of the rules contingently enabled emergent behaviors? 
- What's the role of rules and processes in your work?
- How does this mini-exericse help you to understand generativity and automatism? Do you have any further thoughts about the theme of this chapter? 

## Required reading:
- Montfort, N, et al. "Randomness". *[10 PRINT CHR$(205.5+RND(1)); : GOTO 10](https://10print.org/)*, The MIT Press, 2012, pp. 119-146 (The chapter: Randomness)
- [6 mins video] [Langton's Ant Colonies](https://www.youtube.com/watch?v=w6XQQhCgq5c)
- [noise() vs random() - Perlin Noise and p5.js Tutorial by Daniel Shiffman](https://www.youtube.com/watch?v=YcdldZ1E9gU)
- [p5.js - 2D Arrays in Javascript by Daniel Shiffman](https://www.youtube.com/watch?v=OTNpiLUSiB4) 

## Further reading:
- Langton, Chris G. (1986). "[Studying artificial life with cellular automata](https://deepblue.lib.umich.edu/bitstream/2027.42/26022/1/0000093.pdf)". Physica D: Nonlinear Phenomena. 22 (1–3): 120–149.
- [The Game of Life (1970)](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life) by John Horton Conway
- [The Recode Project](http://recodeproject.com/) and [Memory Slam](http://nickm.com/memslam/) by Nick Montfort
- Galanter, Philip. "[Generative Art Theory](http://cmuems.com/2016/60212/resources/galanter_generative.pdf)". *A Companion to Digital Art*. Eds. Christiane P, 2016.
- [How to Draw with Code by Casey Reas](https://www.youtube.com/watch?v=_8DMEHxOLQE)
- [p5.js Coding Challenge #14: Fractal Trees - Recursive by Daniel Shiffman](https://www.youtube.com/watch?v=0jjeOYMjmDU)
- [p5.js Coding Challenge #76: Recursion by Daniel Shiffman](https://www.youtube.com/watch?v=jPsZwrV9ld0)

## Notes

[^Turing]: Alan Mathison Turing, "On Computable Numbers, with an Application to the Entscheidungsproblem", *Proceedings of the London Mathematical Society* 2.1 (1937): 230-265.
[^Turing1]: Ibid., 241.
[^visualization]: A visualization of the Turing Machine can be found here: https://turingmachine.io/.
[^Lippard]: Reference to Lucy Lippard, ed. *Six Years: The Dematerialization of the Art Object from 1966 to 1972* (London: University of California Press, 1997). 
[^Cox]: One example of many, and also connected to an exhibition, is Geoff Cox's' "Generator: The Value of Software Art", in Judith Rugg and Michèle Sedgwick, eds., *Issues in Curating Contemporary Art and Performance* (Bristol: Intellect, 2007), 147-162; available at https://monoskop.org/images/5/53/Cox_Geoff_2007_Generator_The_Value_of_Software_Art.pdf. Interestingly, this includes a description of Adrian Ward's *Auto-Illustrator*, released as a boxed version for the exhibition "Generator" (2002-3) with an accompanying "User’s  Manual" that contained both technical detail and critical essays. In many ways this sets a precedent for the publication you are reading.
[^exhibition]: The exhibition "Programmed: Rules, Codes, and Choreographies in Art, 1965–2018" was held at the Whitney Museum of American Art, New York (28 Sep 2018 – 14 Apr 2019), and organized by Christiane Paul and Carol Mancusi-Ungaro, with Clémence White. See https://whitney.org/exhibitions/programmed. An earlier well-cited example would be the 1970 exhibition “Software — Information Technology: Its New Meaning for Art” at the Jewish Museum in New York, curated by Jack Burnham. For Burnham, the exhibition "Software" encouraged an understanding of underlying structures in art and information systems, and by drawing together practices in computer technology with conceptual art, software was to be seen as a metaphor for information exchange. 
[^LeWitt]: Sol LeWitt cited in Lippard, ed. *Six Years: The Dematerialization of the Art Object from 1966 to 1972*. 
[^Reas]: For an explanation of this work, and linked docuementation, see Casey Reas, "{Software} Structures",  https://artport.whitney.org/commissions/softwarestructures/text.html
[^joan]: See more of her works here: http://joantruckenbrod.com/gallery/# DELETE??????
[^galanter]: Philip Galanter, *What is Generative Art? Complexity theory as a context for art theory*. In GA2003-6th Generative Art Conference, Milan (2003). 
[^10print]: Nick Montfort, et al, *10 PRINT CHR $(205.5+ RND (1));: GOTO 10* (Cambridge, Mass., MIT Press, 2012_.
[^Haahr]: Mads Haahr, "Introduction to Randomness and Random Numbers", https://www.random.org/randomness/.
[^Langton]: Christopher G. Langton, “Studying Artificial Life with Cellular Automata”, *Physica D: Nonlinear Phenomena* 22, no. 1–3 (October 1986): 120–49. https://doi.org/10.1016/0167-2789(86)90237-X.
[^shiffman1]: See "Two-dimensional Arrays" written for the Processing Community: https://processing.org/tutorials/2darray/.
[^shiffman2]: See the video intruction on 2D Arrays in p5.js: https://www.youtube.com/watch?v=OTNpiLUSiB4.
[^emergence]: For more on emergent behaviour, eee Steven Johnson, *Emergence: The Connected Lives of Ants, Brains, Cities and Software* (London: Penguin, 2001), 20). 
[^smart]: See the artwork *WUOUS* by Anders Visti and Tobias Stenberg with an implementation of *Langton's Ant* to question the procedural logic of so-called 'smart cities': https://andersvisti.dk/work/wuos-2019. 
[^chaos]: Ilya Prigogine and Isabelle Stengers, *Order Out of Chaos: Man’s New Dialogue With Nature* (London: Fontana, 1985), 205.
[^morpho]: Alan Mathison Turing, "The Chemical Basis of Morphogenesis" (PDF). *Philosophical Transactions of the Royal Society of London B*, 237 (641) (1952): 37–72. doi:10.1098/rstb.1952.0012. JSTOR 92463. 
[^Bifo]: Franco Berardi, The Soul at Work, 187. ???????????????????????
[^Noah]: Noah Wardrip-Fruin, "Christopher Strachey: The First Digital Artist?". *Grand Text Auto*, School of Engineering, University of California Santa Cruz (1 August 2005).
[^Gaboury]: Jacob Gaboury, "A Queer History of Computing", *Rhizome* (9 April 2013).   
[^loveletters]: David Link's *LoveLetters_1.0: MUC=Resurrection* was first exhibited in 2009, and was part of dOCUMENTA(13), Kassel, in 2012. A detailed description and documentation can be found at http://www.alpha60.de/art/love_letters/. Also see Geoff Cox, Introduction" to David Link, *Das Herz der Maschine* (dOCUMENTA (13): 100 Notes - 100 Thoughts, 100 Notizen - 100 Gedanken # 037) (Berlin: Hatje Cantz, 2012).  



[these need to just operate as references I think /g]

[^Watz]: For instance, generative artist Marius Watz would suggest that "autonomy is the ultimate goal". Marius Watz (2007). "Beautiful Rules: Generative Models of Creativity", in *The Olhares de Outono* (2007), https://vimeo.com/26594644.
[^Steps]: See the web-based step by step running of the Langton's Ant which is implemented by Barend Köbben in 2014. https://kartoweb.itc.nl/kobben/D3tests/LangstonsAnt/.
[^Moreira]: Andrés Moreira, Anahí Gajardo and Eric Goles. “Dynamical Behavior and Complexity of Langton’s Ant.” *Complexity* 6, no. 4 (March 2001): 46–52. https://doi.org/10.1002/cplx.1042.
