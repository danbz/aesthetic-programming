Title: Automatisms
page_order: 6

## Automatisms 
[is this the best title? - all others are two words as camel text - squashed together. for consistency we shoukd do the same. and what is it really about? maybe MachineOperations or AutoGeneration ??/g]
## setup() 

Following the previous discussion of abstraction concerning objects, this chapter introduces the idea of the abstract machine. By this we refer to the creation of rules generated by a self-operating machine, widely known as an abstract machine or Turing machine. It was mathematician and computer scientist Alan Turing who first described this kind of machine automation in his infamous article "On Computable Numbers, with an Application to the Entscheidungsproblem", published in 1936.[^Turing] He uses the term *universal computing machine* to theorize a model that describes how a machine "can be used to computate any computatable sequence",[^Turing1] understood as how a machine operates and follows a predetermined sequence of instructions that process input and produce output results. 

More specifically, the Turing machine is capable of six types of fundamental operations (at that time there wasn't a thing called a computer) — including read, write, move left, move right, change state and halt/stop. Turing suggested these operations could be performed via running an endless tape (akin to memory/storage in a modern computer) with instructions on what symbols to read and write, as well as how to move. These instructions are fundamental to the Turing machine,[^visualization] but also modern computing, that has the capability to compute tasks in numbers and self-operate. These instructions in turn pervade digital culture and seem to underwrite the wider processes of production, consumption and distribution of contemporary (informational) capitalism.    

![turing](ch6_1.jpg)

*Figure 6.1: An illustration of the Turing Machine*

This chapter thus focuses on instructions, and explores how instructions are fundamental elements of automatic and autonomous processes. Although the previous chapter was also about rules in terms of how objects (e.g. tofu and beer) appear and could be interacted with, this chapter will be more about how rules are performed and how they might produce unpredictable results. 

Focusing on rules and instructions are not only something programmers do, but also something you do when following a knitting pattern or recipe (as we will see with or exmaple of the preparation of tofu later). Artists have also produced artworks that are instruction-based as in the case of the Fluxus and the Conceptual Art movements of the 1960s and 1970s that set out to challenge art's object-ness, and its "dematerialsation".[^Lippard] There are many examples of commentators making the connections between these instruction-based works and computational art,[^Cox] for instance the survey exhibition *Programmed: Rules, Codes, and Choreographies in Art, 1965-2018*,[^exhibition], organized by Christiane Paul at the Whitney Museum of American Art (2018-19), explored how instruction-based practices have both responded to and been shaped by technologies. The work of artist Sol Le Witt is one of the key examples here, demonstrating how a concept is based on a set of instructions but the outcome might be different depending on the specific context and how the instructions are executed by other people. LeWitt explains: "The idea becomes a machine that makes the art".[^LeWitt] For example, the work *Wall Drawing #289* consists of three simple instructions but without specific detail on the angles and length of the lines:

1. twenty-four lines from the center 
2. Twelve lines from the midpoint of each of the sides
3. Twelve lines from each corner 

![drawing2](ch6_2.jpg)
*Figure 6.2: Sol LeWitt, Wall drawing #289, 1976* [if copyright a problem then use a casey reas example maybe /g]

It becomes clear how conceptual practices combine idea and action in parallel to how performance works with scores and scripts, and in turn how programs work with instructions and their execution. LeWitt's work lends itself well to computation, and this was taken up by Casy Reas using Processing to render LeWitt's wall drawings from their instructions and thus to explore the parallels of interpretation and process in each case.[^Reas] Despite the LeWitt quote above, in his accompanying text he makes an important distinction in that LeWitt's programs are to be executed and interpreted by people rather than machines a such. Yet it is the close connection and overlaps that interests Reas — also underlying the development of the Processing as a "software sketchbook" — wanting programming to be as immediate and fluid as the practice of drawing. 
 
/ [I would be tempted to drop this example - good as it is, and a woman - and the next section follows Reas well /g] Another example is Joan Truckenbrod who has shown her work *Coded Algorithmic Drawing (#9)* in the same show. The piece with a number of squares of variations in size and angle was coded with the programming language Fortran in the 1970s, simulating moving substance in natural phenomena.[^joan]
![drawing3](ch6_3.png)

*Figure 6.3: Joan Truckenbrod, Coded Algorithmic Drawing, 1975* /

This kind of approach is important not only because of offering a different way to draw and author works by machines based on mathematical logic, but also to provide a sense of machinic creativity that — as in the previous chapter — questions the centrality of human (more often than not, male) agency. In this chapter we aim to explore more complex (posthuman) combinations that combine people and machines (if not animals, as our upcoming example is an ant). 

If we were to draw an ellipse in white color at the x and y coordinate 100 and 120, there is a direct correspondance to the instruction. The outcome is predictable as the instruction is followed unambiguosuly but this need not be the case as certain kinds of instructions or a lots of instructions can generate unpredictable results. This *generative* quality throws into question the extent of control and autonomy over the creative process, made clear in the following definition of generative art:[^galanter]
> Generative art refers to any art practice where artists use a system, such as a set of natural languages, rules, a computer program, a machine, or other procedural invention, which is set into motion with some degree of autonomy contributing to or resulting in a completed work of art.

Interestingly, as we can see this definition does not limit itself to the use of computers and this is important to bear in mind as we proceed to focus on our sample code. In the following two examples we explore rule-based programs that unfold some of these issues of autonomy, but as with previous ones we are interested in the wider implications. 

## start()

The first program is called *10 PRINT* based on one line of program code `10 PRINT CHR$(205.5+RND(1));: GOTO 10`, written in the BASIC programming language and executed on a Commodore 64 home computer. It generates an endless pattern on the screen. It is printed in the 1982 *Commodore 64 User's Guide* and later published on the web. This line of code has become an important example in the field of software studies to demonstrate the history and culture of creative computing.[^10print] *10 PRINT* in `p5.js` below is used to help us become familiar with rules and its creative potential to demonstrate some degree of autonomy within a system.  

The second program is *Langton's Ant* (1986), a two-dimensional universal Turing machine invented in 1986 by the computer scentist Christopher Langton who is considered to be one of the founders of field of Artificial life.[^Langton] The core difference with *10 PRINT* is the way that complex emergent behavior is generated with only a simple set of rules. 

## Exercise in class (10 PRINT)

![drawing4](ch6_4.png)

*Figure 6.4: 10 PRINT in p5.js*

[RUNME](https://gitlab.com/siusoon/Aesthetic_Programming_Book/blob/master/sample_codes/p5_SampleCode/ch6_Automatisms/index.html)

1. Read the source code of *10 PRINT* then copy it and run it on your own computer.

```javascript
let x = 0;
let y = 0;
let spacing = 10;

function setup() {
  createCanvas(windowWidth,windowHeight);
  background(0);
}

function draw() {
  stroke(255);
  if (random(1) <0.5) {  
    line(x,y,x+spacing,y+spacing);
  } else {
    line(x,y+spacing,x+spacing,y);
  }
  x+=10;
  if (x > width) {
    x = 0;
    y += spacing;

  }
}
```

2. Discuss the following rules of *10 PRINT* and map them to the related lines of code:
    - Throw a dice randomly and half of the time print a backward slash
    - The other half of the time will print a forward slash

3. Discuss the use and the role of randomness in *10 PRINT* and in the arts, literature, and games? What is randomness to a computer?[^Haahr]  

4. Try to modify the existing rules, for example: 
    - Can we have other outputs than just the backward and forward slash?
    - Can we chnage the size and color of the slashes? 

5. *10 PRINT* has been appropriated by many artists, designers and students. Take a look at some of the different possibilities for [*10 PRINT*](https://twitter.com/search?q=%2310print&src=typd) that are documented on Twitter. Your in-class task is to create a sketch with a clear set of rules and that operates as a modified version of *10 PRINT*.  

## Langton's Ant 

*Langton's Ant* is a classical mathematical game that simulates the molecular logic of a living ant. The simulation of the cell's state is inspired by the classical Turing machine that can perform computational tasks with the manipulation of symbols on a strip of tape according to a set of rules. 

[more on this in the context of generative art and introduce cellular automaton - game of life /g]

This section presents sample code to simulate the cell states, presenting in a two-dimensional grid system in either the color black or white. Based on simple rules, an ant is considered to be the input source that will change the state of the cell by moving in four directions. The ant will gradually turn the grid into a more complex system that exhibits emergent behavior over time.

![drawing5](ch6_5.gif)

*Figure 6.5: Langton's Ant - Initial steps*

With the initial direction of an ant pointed upwards (i.e. North position), figure 6.5 shows the initial 33 steps of  *Langton's Ant* in following the two general rules below:

1. If the ant is at a white cell, it turns right 90° and changes to a black cell then moves forward one unit.
2. If the ant is at a black cell, it turns left 90° and changes to a white cell then moves forward one unit. 

At the beginning, the canvas displays only a grid system and all the individual cells are set in white color. The ant has  four possible directions — UP, RIGHT, DOWN, LEFT — and can turn 90° either left or right subject to the color of the cell. The ant's head is pointing in an UPWARD position at the start, and is located in the middle of the white grid. It then follows rule 1 above to rotate the head direction from UP to RIGHT, then it also changes the white cell to the black and moves forward one unit (pointing to the right as per the new head direction). Then the second step is to follow rule 1 again because the new cell is still white. The ant's head direction will turn right 90° and point from RIGHT to DOWN, and then changes the white cell to black and the ant moves forward one unit. Then the third and forth steps are similar to the previous ones until the ant meets a cell which is black, which is started in step 5. At this point, the ant will follow rule 2 instead to change back cell's color back to white and then turns left 90° instead of the right. The complexity builds. 

![drawing6](ch6_6.gif)

*Figure 6.6: Langton's Ant - Process*

Figure 6.6 shows how the ant starts building the emergent 'highway' pattern[^Moreira] after the first few hundred moves with simple symmetricial patterns. It is then followed by an additional 9000 steps[^Steps] with the seemingly random steps at the center. The highway pattern repeats indefinitely until most of cells are reconfigured, leading to something that is similar to Figure 6.7 at which point the ant is still constantly moving and changing the color of the cells.

![drawing7](ch6_7.png)

*Figure 6.7: Langton's Ant - A snapshot of emergence*

[RUNME](https://gitlab.com/siusoon/Aesthetic_Programming_Book/blob/master/sample_codes/p5_SampleCode/ch6_Automatisms/sketch_6_1/index.html)

## Source code (Langton's Ant)
```javascript
let grid_space = 5; //e.g. 4, 5, 10 need to be dividable as an integer by the width and height of the canvas
let grid =[]; //on/off state
let cols, rows; //for drawing the grid purpose
let xPos, yPos; //current position in terms of rows and cols, not actual pixel
let dir; //current direction of the ant
const antUP = 0;
const antRIGHT = 1;
const antDOWN = 2;
const antLEFT = 3;
let offColor;
let onColor;

function setup() {
  createCanvas(1000,700);
  offColor = color(255); //setting offcolor
  onColor = color(0); //setting onColor
  background(offColor);
  grid = drawGrid();
  xPos = floor(cols/2); //initial x position and make sure it is an integer in the grid array
  yPos = floor(rows/2); //initial y position and make sure it is an integer in the grid array
  dir = antUP; //initial direction
  frameRate(20);
}

function draw() {
  for (let n = 0; n < 100; n++) { //for running faster per frame, try changing the n value
   checkEdges();
   let state = grid[xPos][yPos]; //check the current cell's state
   if (state == 0) { //rule 1
    dir++; // turn right 90°
    grid[xPos][yPos] = 1; //change the currect cell's state to 'on'
    fill(onColor); //subsequent color change
    if (dir > antLEFT) {
      dir = antUP; //reset the counter
    }
   }else{ //rule 2
    dir--; //turn left 90°
    grid[xPos][yPos] = 0; //change the current cell's state to 'off'
    fill(offColor); //subsequent color change
    if (dir < antUP) {
      dir = antLEFT; //reset the counter
    }
   }
   rect(xPos*grid_space, yPos*grid_space, grid_space, grid_space);
   nextMove();
  }
}
function drawGrid() {
  cols = width/grid_space;
  rows = height/grid_space;
  let arr = new Array(cols);
  for (let i=0; i < cols; i++) { //no of cols
    arr[i] = new Array(rows); //2D array
    for (let j=0; j < rows; j++){ //no of rows
      let x = i * grid_space; //actual x coordinate
      let y = j * grid_space; //actual y coordinate
      stroke(0);
      strokeWeight(1);
      noFill();
      rect(x, y, grid_space, grid_space);
      arr[i][j] = 0; //assign each cell with the off state + color
    }
  }
  return arr; //a function with a return value of the cell's status
}

function nextMove () { //check which direction to go next and set the new current direction
  if (dir == antUP) {
    yPos--;
  } else if (dir == antRIGHT) {
    xPos++;
  } else if (dir == antDOWN) {
    yPos++;
  } else if (dir == antLEFT) {
    xPos--;
  }
}

function checkEdges() { //check width and height boundary
  if (xPos > cols-1) { //reach the right edge
    xPos = 0; //go back to the left
  } else if (xPos < 0) { //reach the left edge
    xPos = cols-1; //go to the right edge
  }
  if (yPos > rows-1) { //reach the bottom edge
    yPos = 0; //go back to the top
  } else if (yPos < 0) { //reach the top edge
    yPos = rows-1; //go to the bottom
  }
}

```

## Reading Langton's Ant

Based on the above example, there are three areas can help in slowing down or zooming in on the program. 
1. `let grid_space = 5;`: You can change the value to 10 then you are able to see it at a larger size.   
2. `frameRate(20);`: Lower the frameRate value can help slow down the program
3.  `draw()`: This function contains a for-loop where n is the number of steps of the ant so if desired you can reduce the `n < 100` to `n < 1` in the line `for (let n = 0; n < 100; n++) {` thus instructing the program to only process n steps per frame.

Intead of going through the code line by line, this next part is more to show what each function does. 

- `function setup()`: This is more to setup the canvas size, initiate the ant's head direction, frameRate, color and to prepare drawing the background grid structure. 

- `function drawGrid()`: To divide the canvas into a grid structure with lines.

- `function draw()`: This is the main function to check against the two rules of Langton's Ant and change the color of cells. 

- `function nextMove()`: The four directions are structured in a number format so that the variable `dir++` can be used for incrementing or decrementing the ant's direction. Each different direction of *UP, RIGHT, DOWN, LEFT* corresponds to moving forward in either horizontal (xPos) or vertical (yPos) steps on the canvas. 

- `function checkEdges()`: This function is to check if the ant moves out of the four edges, then it will continue at the other end. 

Technically speaking, there is no new syntax here as the 2-dimensional arrays have already been covered briefly in Chapter 4 - Data Capture. However, there is the new use of 2-dimensional arrays and nested for-loops in the sample code. 

## 2-dimensional Arrays & Nested for-loops

Daniel Shiffman has created a tutorial (both in written[^shiffman1] and video[^shiffman2] formats) to discuss how a 2-dimensional array is essentially an array of other arrays. He also suggests that it is useful to think about 2-dimensional arrays with a grid structure which aligns nicely with the background of *Langton's Ant* designed as a grid in two dimensions with both columns and rows. Since we need to identify the state of each cell, we need to know the exact x and y position of each cell. 

Let's examine the source code again for the grid drawing: 

```javascript
function drawGrid() {
  cols = width/grid_space;
  rows = height/grid_space;
  let arr = new Array(cols);
  for (let i=0; i < cols; i++) { //no of cols
    arr[i] = new Array(rows); //2D array
    for (let j=0; j < rows; j++){ //no of rows
      let x = i * grid_space; //actual x coordinate
      let y = j * grid_space; //actual y coordinate
      stroke(0);
      strokeWeight(1);
      noFill();
      rect(x, y, grid_space, grid_space);
      arr[i][j] = 0;  //assign each cell with the off color and link to individual cells
    }
  }
  return arr; //a function with a return value
}
```

To create an array, we use the syntax `let arr = new Array(cols);` and this line indicates the grid in columns and the length of the array is the number of columns. Since we also need to cater for the number of rows, we create another array out of each existing array in the column with the line `arr[i] = new Array(rows);`. This syntax is put under a for-loop to loop through each of the columns but then with the addition of number of rows (which is derived from the canvas's height). Therefore, 2-dimensional arrays are visualized in this way: `arr[][]`. 

In order to know the exact x and y coordinates of each cell within a grid structure, it depends on which columns and which rows you are pointing at with the formular `x = i * grid_space;` and `y= j * grid_space;` respectively. By using two nested for-loops, the program will loop through each column and each row (under the same column) until the program runs to the last column. Ultimately, we are able to get the x and y coordinates with the syntax `array[i][j]`, which is applied to columns (with the variable i) and rows (with the variable j).

Therefore, each divided cell is presented in the structure of a 2-dimensional array. It depends on the width and height of the canvas and how you want to distribute the space. Each cell represents a possibility that an ant can move as a unit and demonstrate an on/off state that is represented in the color labck or white. 

## Exercise in class

1. Give yourself sometime to read and tinker with the code, as well as to observe the different stages of *Langton's Ant*. 

2. Right now the *Langton's Ant* program is more about representing the world of an ant through abstraction, such as limited cell color, as well as only being able to move in four directions and turn 90°. Rethink the rules that have been implemented. Can you try changing the existing rules or adding new rules so that the ant behaves differently? (Recall what you have changed in the previous exercise on *10 PRINT*.) 

3. It is clear that in simulating and abstracting living systems — such as the complex behaviour of insects — there is a focus on emergent and generative process over end-result. In terms of creative process this allows us to think about how rules and instructions can produce complexity and other forms of control and agency. 
Let's discuss the following questions:
- Can you think of and describe other systems and processes that exhibit emergent behaviour? 
- How would you understand autonomy and agency in this context?[^Watz] 
- To what extent do you consider the machine to be an active agent in generative and autonomous systems? What are the implications for wider culture?

## While()

[I will get onto this next week I hope /g]
- nature / technical/ culture / reproduction (feminist approach)? 
- authorship/ power / control / unpredictability? 
- order, disorder, chaos, complex system, emergence? cellular automata, game of life
- more on automatism and production, and autonmy as power to determine life
- ideas as form 
- Focus on rules, orders, chaos, emergent behaviors ?
- Generators and other automatisms (genotypes), love letter generators

## Mini_Exercise[6]: A generative program

**Objectives:**
- To implement a rule-based generative program from scratch.
- To strengthen the computational use of loops and conditional statements in a program.
- To reflect upon the concept of automatism conceptually and practically.

**To get some additional inspiration here:**
- [{Software} Structure #003 A by Casey Reas](https://whitney.org/exhibitions/programmed?section=1&subsection=6#exhibition-artworks)
- [Generative Design - sketches](http://www.generative-gestaltung.de/2/), [soure code](https://github.com/generative-design/Code-Package-p5.js)
- [GenArt (with source code)](https://github.com/JosephFiola/GenArt) by JosephFiola, see ch.1-4
- [Open Processing with the search keyword 'generative'](https://www.openprocessing.org/browse/?q=generative&time=anytime&type=all#)
- [John Conway's Game of Life](http://web.stanford.edu/~cdebs/GameOfLife/)
- [The recode project](http://recodeproject.com/) or https://web.archive.org/web/20181227225001/http://www.recodeproject.com/
- [WUOUS by Anders Visti and Tobias Stenberg](https://andersvisti.dk/work/wuos-2019) (with an implementation of the Langton's Ant)

**Tasks (RUNME):**
1. Start with a blank paper. Think of at least two simple rules that you want to implement in a generative program. (You may take reference from Langton's ant (1986) and The Game of Life (1970))
2. Based on the rules that you set in step 1, then design a generative program that utilizes at least one for-loop/while-loop and one conditional statement but without any direct interactivity. Just let the program runs and emerges automatically.(You may also consider to use `noise()` and `random()` syntax if that helps)

**Questions to think about as README:**
- What are the rules in your generative program and describe how your program performs over time and how are the running of the rules contingently enabled emergent behaviors? 
- What's the role of rules and processes in your work?
- How does this mini-exericse help you to understand what might be generativity and automatism? Any thoughts about the theme of this chapter? 

## Required readings:
- Montfort, N, et al. "Randomness". *[10 PRINT CHR$(205.5+RND(1)); : GOTO 10](https://10print.org/)*, The MIT Press, 2012, pp. 119-146 (The chapter: Randomness)
- [6 mins video] [Langton's Ant Colonies](https://www.youtube.com/watch?v=w6XQQhCgq5c)
- [noise() vs random() - Perlin Noise and p5.js Tutorial by Daniel Shiffman](https://www.youtube.com/watch?v=YcdldZ1E9gU)
- [p5.js - 2D Arrays in Javascript by Daniel Shiffman](https://www.youtube.com/watch?v=OTNpiLUSiB4) 

## Further readings:
- Langton, Chris G. (1986). "[Studying artificial life with cellular automata](https://deepblue.lib.umich.edu/bitstream/2027.42/26022/1/0000093.pdf)". Physica D: Nonlinear Phenomena. 22 (1–3): 120–149.
- [The Game of Life (1970)](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life) by John Horton Conway
- [The Recode Project](http://recodeproject.com/) and [Memory Slam](http://nickm.com/memslam/) by Nick Montfort
- Galanter, Philip. "[Generative Art Theory](http://cmuems.com/2016/60212/resources/galanter_generative.pdf)". *A Companion to Digital Art*. Eds. Christiane P, 2016.
- [How to Draw with Code by Casey Reas](https://www.youtube.com/watch?v=_8DMEHxOLQE)
- [p5.js Coding Challenge #14: Fractal Trees - Recursive by Daniel Shiffman](https://www.youtube.com/watch?v=0jjeOYMjmDU)
- [p5.js Coding Challenge #76: Recursion by Daniel Shiffman](https://www.youtube.com/watch?v=jPsZwrV9ld0)

## Notes

[^Turing]: Alan Mathison Turing, "On Computable Numbers, with an Application to the Entscheidungsproblem", *Proceedings of the London Mathematical Society* 2.1 (1937): 230-265.
[^Turing1]: Ibid., 241.
[^visualization]: A visualization of the Turing Machine can be found here: https://turingmachine.io/.
[^Lippard]: Reference to Lucy Lippard, ed. *Six Years: The Dematerialization of the Art Object from 1966 to 1972* (London: University of California Press, 1997). 
[^Cox]: One example of many, and also connected to an exhibition, is Geoff Cox's' "Generator: The Value of Software Art", in Judith Rugg and Michèle Sedgwick, eds., *Issues in Curating Contemporary Art and Performance* (Bristol: Intellect, 2007), 147-162; available at https://monoskop.org/images/5/53/Cox_Geoff_2007_Generator_The_Value_of_Software_Art.pdf. Interestingly, this includes a description of Adrian Ward's *Auto-Illustrator*, released as a boxed version for the exhibition "Generator" (2002-3) with an accompanying "User’s  Manual" that contained both technical detail and critical essays. In many ways this sets a precedent for the publication you are reading.
[^exhibition]: The exhibition "Programmed: Rules, Codes, and Choreographies in Art, 1965–2018" was held at the Whitney Museum of American Art, New York (28 Sep 2018 – 14 Apr 2019), and organized by Christiane Paul and Carol Mancusi-Ungaro, with Clémence White. See https://whitney.org/exhibitions/programmed. An earlier well-cited example would be the 1970 exhibition “Software — Information Technology: Its New Meaning for Art” at the Jewish Museum in New York, curated by Jack Burnham. 
[^LeWitt]: Sol LeWitt cited in Lippard, ed. *Six Years: The Dematerialization of the Art Object from 1966 to 1972*. 
[^Reas]: For an explanation of this work, and linked docuementation, see Casey Reas, "{Software} Structures",  https://artport.whitney.org/commissions/softwarestructures/text.html
[^joan]: See more of her works here: http://joantruckenbrod.com/gallery/# DELETE??????
[^galanter]: Philip Galanter, *What is Generative Art? Complexity theory as a context for art theory*. In GA2003-6th Generative Art Conference, Milan (2003). 
[^10print]: Nick Montfort, et al, *10 PRINT CHR $(205.5+ RND (1));: GOTO 10* (Cambridge, Mass., MIT Press, 2012_.
[^Haahr]: Mads Haahr, "Introduction to Randomness and Random Numbers", https://www.random.org/randomness/.
[^Langton]: Christopher G. Langton, “Studying Artificial Life with Cellular Automata”, *Physica D: Nonlinear Phenomena* 22, no. 1–3 (October 1986): 120–49. https://doi.org/10.1016/0167-2789(86)90237-X.
[^shiffman1]: See "Two-dimensional Arrays" written for the Processing Community: https://processing.org/tutorials/2darray/.
[^shiffman2]: See the video intruction on 2D Arrays in p5.js: https://www.youtube.com/watch?v=OTNpiLUSiB4.


[these need to just operate as references I think /g]
[^Smart]: See the artwork *WUOUS* by Anders Visti and Tobias Stenberg with an implementation of *Langton's Ant* to question the procedural logic of so-called 'smart cities': https://andersvisti.dk/work/wuos-2019. 
[^Watz]: For instance, generative artist Marius Watz would suggest that "autonomy is the ultimate goal". Marius Watz (2007). "Beautiful Rules: Generative Models of Creativity", in *The Olhares de Outono* (2007), https://vimeo.com/26594644.
[^Steps]: See the web-based step by step running of the Langton's Ant which is implemented by Barend Köbben in 2014. https://kartoweb.itc.nl/kobben/D3tests/LangstonsAnt/.
[^Moreira]: Andrés Moreira, Anahí Gajardo and Eric Goles. “Dynamical Behavior and Complexity of Langton’s Ant.” *Complexity* 6, no. 4 (March 2001): 46–52. https://doi.org/10.1002/cplx.1042.
