Title: 0. *Aesthetic Programming: A Handbook of Software Studies*
page_order: 0

*Aesthetic Programming: A Handbook of Software Studies*

## Preface

### What kind of book is this?

Reading its subtitle, this book is clearly meant to be a handbook of sorts, but not in any conventional sense of it being a prescribed set of technical instructions (like a cook book) in order to find out how to do something like coding in a straightforward fashion, for beginners.[^instructions] As such this handbook is not simply meant to be read in order to learn to code or indeed to offer critical reflection upon the practice of coding alone. Instead, it is something more messy and at the same time more ambitious we would say: a book to represent a more complex and deeply entangled set of relations between writing, coding and thinking: to provide some "useful knowledge".[^useful]

Most programming books are written with a primary objective of teaching readers how to learn a programming language to become a good (or better) programmer, with an emphasis on state-of-the-art technology, as well as practical examples that are explained and then designed to be deployed in IT-related or creative industries. Not many programming books address the cultural and aesthetic dimensions of programming as a means to think and act critically. In emerging trans-disciplinary fields involving computational technology — such as software studies, platform studies, and digital humanities to an extent — the practice of programming is incorporated into the object of study and yet little practical detail is provided in terms of putting programming into a critical perspective, especially for those studying non-technical or scientific disciplines. This book attempts to address this perceived gap in literature and the growing interest in *computational thinking*[^ct] to expand programming beyond the confines of computer science (or even the digital humanities, which presents a set of other limitations). We consider our approach to be distinctive from other books that are more focused on programming from an engineering perspective, as well as distinctive from other theoretical books where source code becomes an illustration of the programmer's thinking or too-easy analogy to the hidden layers of operations (if not ignored altogether).

Whilst operating broadly in the spirit of Software Studies,[^Fuller] the book offers an applied and overtly practice-based approach to understanding the centrality of programming — the reading, writing and thinking with software — as a critical tool for our times, in recognition of the way in which our experiences are ever more programmed. It is offered as a deep learning *tool* in its widest sense — a handbook for those unaccustomed to programming — that allows for the conceptual agency of the programmer to develop as they become more proficient in their technical skills.

To reiterate, our intention is that readers will acquire key skills of programming in order to read, write and think with, and through, code (and we will return to the issue of literacy later). We see that it is important to further explore the intersections of technical and cultural aspects of code in order to reflect deeply on the pervasiveness of computational culture and its social and cultural effects — from the language and politics of human-machine languages to abstraction of objects, datafication and recent developments in automated machine intelligence, for example. In other words, the book embraces both the technical aspect and formal qualities of code as well as imaginaries of code, including acknowledgement of the material conditions of programming practice, the nonhuman agency of code itself, and its inherent relationality.     
We aim to bridge the gap between theories of computational culture, aesthetics and cultural studies, alongside learning to program. As part of this, we take a particular interest in power relations that are under-acknowledged, such as inequalities related to class, institutions and corporations, gender and sexuality, as well as race. This is not only related to the politics of representation but also how power differentials are implicit in code that is not neural, in terms of binary logic, hirerarchies, naming of attributes, accessibility and how wider societal inequalities are further reinforced and perpetuated through nonrepresentational computation. In short, the handbook introduces and demonstrates a distinctive approach through the intersectional and reflexive practice of aesthetic programming as we understand it.

### So why aesthetic programming?

The argument the book follows is that computational culture is not just a trendy subject to study, or a way to understand more about what is happening with computational processes, but a means to engage with programming as a way to question existing technological interfaces and further create changes in the technical system. Thus we consider programming to be a dynamic cultural practice and phenomenon, a way of thinking and doing in the world, and a means to understand some of the complex procedures that underwrite our lived realities, in order to act upon those realities.  

We consider that the phrase *aesthetic programming* best describes this approach. We claim a certain distinctiveness in this, but of course aesethetic programming comes close to other phrases such as *creative coding* and *exploratory programming* that have been introduced in related literature in recent years: to emphasize the expressivity of computer programming beyond something pragmatic and functional, in which cultural production, or critical thinking through the practice of programming, can be cultivated and developed from the broad perspective of the arts and humanities.[^Refs] It should be explained that the title *aesthetic programming* actually derives from one of the undergraduate courses in the Digital Design degree programme at Aarhus University in Denmark, which has been taught alongside a parallel course in Software Studies since 2013. Taken together these courses offer ways to think with software to understand wider political and aesthetic phenomena. We follow the principle that the growing importance of software requires a new kind of cultural thinking — and curriculum — that can account for, and with which to understand better — from the inside — the politics and aesthetics of algorithmic procedures, data processing and abstracted modeling. The structure of the book largely emerges from this experience of teaching these courses and we thank all our students and fellow teachers for their valuable contributions and critical feedback along the way.[^Magda]

To go further, invoking aesthetics, it should be clear that we do not refer to ideas of beauty as it is often misunderstood, but to aesthetics at the core of politics, to what presents itself to sense-making experience and bodily perception (to paraphrase Jacques Rancière's *The Politics of Aesthetics*, for instance).[^Ranciere] How we apprehend the world in this sense is not fixed but in process of endless becoming, much like software itself.

Aesthetics also refers back to the critical theory of the Frankfurt School, and in particular the ideas of Theodor Adorno and Walter Benjamin, to enforce the idea that cultural production — which would include programming for us of course — must be seen in a social context and necessarily has a political function. Programming becomes a kind of *force-field* to understand material conditions and social contradictions, just as the interpretation of art once operated "as a kind of code language for processes taking place within society".[^Jay] Technology clearly plays its part here, and the infamous artwork essay by Benjamin becomes a touchstone for dismantling some of the associated myths of artistic production including the dismantling of authenticity and the aesthetic experience of *aura* (the mark of its authenticity and originality).[^Benjamin] It is worth remembering that Adorno and Benjamin famously disagreed on the consequences of this destruction of aura: whilst Benjamin expressed the positive aspects of this shift and the destruction of aura is a kind of political emancipation, Adorno expressed the negative view that standardisation and pseudo-individuality would follow. We can clearly see these tendencies have accelerated with computational culture and hence the continuing need for sharp critique, and one also based along the lines of "immanent criticism" — that which is inherent, as it operates within its object — in the inner workings of software and its material conditions.[^Adorno] The question remains as to what extent these old (white, male) references are up to the task of unpicking the complexity of computational operations, and address the ways in which most people use computers or think about them. This is as much to do with what aesthetic programming is becoming as to what it is or was. 

To address this difficulty of upgrade we have been working with fundamental concepts of programming as the starting point for further aesthetic reflection — such as geometry and object abstraction; variables, data types, functions and namings as well as data capturing, processing and automation — thereby the technical functionings are setting the ground works for further understanding of how cultural phenomena is constructed and operationalized. Aesthetic Programming in this sense is considered as a practice to build things but also with the need to produce "reflexive work of critique". This comes close to Philip Agre's notion of "critical technical practice" with the drawing together of two different perspectives: formal technical logic and discursive cultural meaning.[^agre] In other words, this necessitates practical understanding and knowledge of programming to underpin critical understanding of techno-cultural systems, underpinned by levels of expertise in both fields — as in the case of Wendy Hui Kyong Chun.[^Chun] We hope to encourage more and more people to defy the separation of fields in this way.    

### And software studies?

So we draw heavily upon the field of Software Studies, and to an extent Critical Code Studies — the work of Wendy Chun, Matthew Fuller, Mark Marino and others, including our own earlier work — to deal with and communicate knowledge of software as a cultural form via analyses of examples of software artefacts and close readings of theoretical texts and source code. In terms of approach we take our cue from Matthew Fuller's *Software Studies: A Lexicon* from 2008, structured literally as a lexicon of key terms, it in turn taking its cue from the Raymond Williams's *Keywords: A Vocabulary of Culture and Society* first published in  1958.[^Williams] In many ways, and simply put, our book can be thought of adopting a similar approach of zooming in on the formal logics of computaton and zooming out to the cultural implications of software. In this respect it is also important to recognise that the book *Software Studies* derived from a workshop, and it is worth quoting the project page for its clarity of intention:
"[T]he project aims at folding the internalist/externalist question of science studies inside out, the mechanisms of the one conjugating the subject of the other: what does software-enabled scholarship, in software, art and literary practice have to say about its own medium? The purpose of this interaction is not therefore to stage some revelation of a supposed hidden truth of software, to unmask its esoteric reality, but to see what it is and what it can be coupled with: a rich seam of paradoxical conjunctions in which the speed and rationality of computation meets with its ostensible outside."[^ss]

Like this, we believe that paying attention to fundamental, or key, concepts from programming offers the possibility to open up new insights into aesthetics and critical theory, and new perspectives on cultural phenomena increasingly bound to computational logic. In extending the discussion, beyond formal logic to its outside, we also emphasise the usefulness of artistic practice to open up more speculative and alternative imaginaries. In this spirit, and in keeping with the development of software studies in Europe at least, we take inspiration from what has been referred to as *software art* (although admittedly the category was only meant as a temporary holding position).[^Readme] That we draw upon examples from artistic (and critical design) practices as part of our argument — including close attention to works by one of us (Winnie Soon) — stresses our point that programming is not simply a practical tool that produces an artwork but is a critical-aesthetic object in its own right.[^codestudies] As media theorist Tilman Baumgärtel once neatly clarified:
"Software art is not art that has been created with the help of a computer but art that happens in the computer. Software is not programmed by artists, in order to produce autonomous work, but the software itself is the artwork. What is crucial here is not the result but the process triggered in the computer by the program code."[^Cox]

We would argue something similar for writing this book. Moreover, in order to discuss the aesthetic dimensions of code and computational processes, we incorporate artistic works that explore the material conditions of software and operations of computational processes as practical and theoretical examples. They are an intergal part of our argument in other words, as well as usefully demonstrate some of the ideas in practice and offer unexpected epistemic insights. We might add, and repeating what has already been introduced, that we are not simply interested in a critical aesthetics of programming but also programming as critical aesthetics.

### Open publishing 

More to the point, text is in code (in the ways that it is made human-readable) and code is in text (in the use of the text editor, interfaces and online platforms we use to render these thoughts). There is more to say on this, and we will return to these issues across the various chapters of the book, each following the logic of fundamental programming concepts. Suffice to say for now that the book sets out to express how writing and coding are entangled, and how neither should be privileged over the other: we learn from their relationality. Writing code and writing about code are forced together in ways that reflect broader cultural and technical shifts in data practices and open publishing initiatives, and moreover to emphasise that writing a book is necessarily a work in progress. In other words, this is a book to be read and acted upon, shared and rewritten.

There are clearly many precedents for such an overtly collaborative approach in software production, and clearly free and open source principles underscore our thinking. It is worth emphasising that FOSS development is a collective practice that challenges the normative relations of production associated with commercial development — such as a narrow definition of authorship and copyright — which can be extended to the production of books and the associated reputation economy of academic publishing. But we also recognise that the release of source code and open access books represents a number of ambiguities related to the sharing economy, free market capitalism and opportunities to capitalise on free labour. However we persist in the hope that our efforts challenge reductive logic, and our publisher, Open Humanities Press, broadly reflects FOSS principles of transparency and reproducibility in its commitment to radical open access for scholarly work.[^OHP] As such this book can be downloaded for free or purchased as a hard copy at a reasonable price.

This nothing particularly original in this. We acknowledge other numerous experimental publishing initiatives and even *anti-platforms* such as dokieli for decentralised article publishing.[^dok] There are also plenty of other examples that have picked up on the perversity of writing books about programming where you have to type out the examples to run them, and live coding platforms demonstrate alternatives (e.g. Jupyter Notebook or DevDocs[^devdocs]). Our use of print and associated software repository is our way of managing this problem. This also has informed our choice of designers for the book: Open Source Publishing collective (OSP) design using only free and open source software — "pieces of software that invite their users to take part in their elaboration" as they put it[^OSP] — and make all files freely available through the use of a Git versioning system that contains all the files for the project (the following chapter introduces this), distributed under the terms of the GNU General Public License version 2.   

The use of a Git repository for our writing further emphasises these free and open source working principles, and how by treating writing as software, or indeed software as writing, allows us to formalise the production of the book as an iterative process, in need of timely updates, forking and endless reversioning. In allowing for new versions to be produced by others, we hope in a modest way to challenge commercial publishing conventions and illuminate our capacity to understand some of the infrastructures through which we encode our ideas and distribute them over networks. This way of working then, we believe, is a departure point to engage with programming collectively and create changes in the social-technical systems (both inside out). We aim to do something similar to what Adrian Mackenzie has identified as “auto-archaeology” to indicate how the object of study is fully integrated into the analysis, and demonstrated in the associated GitHub site for his 2017 book *Machine Learners*.[^Mackenzie] This helps us as readers to understand something of the iterative process of writing a book about code in the spirit of how software developers work together, host, review and merge code, and build software together. Git, as a dynamic repository in this way collapses the distinction between storage and production.[^Git]

### Flow of the contents 

Each chapter of the book starts with a flow chart to provide an overview of the practical and conceptual aspects of the chapter as an algorithmic procedure that follows a sequence. It is a technical object for thinking with, especially the relations between the stage setup as expressed in the section 'setup()', starting point as expressed in 'start()', artefacts and sample code as expressed in 'Source Code', formal qualities of code and syntax, through practice as expressed in 'Exercises and Discussion in class', and further extended discussion as expressed in 'While()'. If a flow chart is conventionally used "as an aid to the design of computational processes" both for technical understanding and communication,[^diagram] then we also consider that critical reflection should be an integral part of the process. Indeed, the flow chart serves as the starting point to exemplify our approach of turning concepts *inside out* and the need to understand computational and programmable objects and processes in both logical and discursive forms.

Every chapter comes with an example that utilizes different technical syntax, facilitating the discussion of the formal aspects of code. But beyond that, we also have experienced that students, especially beginners, have difficulty in putting different functions together as a sketch. Although each chapter is built upon others, we have found that it is important to repeat the use of syntax and to show how different functions and syntax can be combined and used in multiple ways. Most individual functions can be searched via the p5.js reference page or available in other instructional online videos, but we want to stress the importance of how to bring things together. Thus, our examples are developed with this in mind to build up complexity progressively, and each sketch has less than 100 lines of code for ease of comprehension. It should be said that we do not take effective and efficient code to be a priority here and sometimes we will twist the expected use of syntax accordingly. Indeed we do not aim to offer a comprehensive list of the core p5 functions like many other programming books. Rather, we offer ways to explain the syntax according to the examples that we have selected and to further discussion. Our examples are inspired by many artists, designers and scientists' work, and they are custom-made according to the perceived pace of learning and reflective potential with the incorporation of syntax and features that are closely aligned with the chapter's focus. The examples are offered to spark both the technical and conceptual discussion in and outside of the classroom. Indeed, they are also closely related to the mini exercises that we have set out for each chapter with the dual elements of RUNME and README to cultivate reflection through writing code and writing about code beyond just the focus on functional and technical syntaxes, and students are free to explore, express and think creatively, conceptually and critially via constructing critical artefacts. When it comes to practice and iterative learning, we have also included peer-feedback for every mini exercise so as to encouarge learning through reading other people's code[^readcode], and to further emphasise the diversity of approaches and ability to sketch out ideas in public.

This book has been developed over the last five years through the actual setting of classroom teaching, but this is in a very particular cultural and educational context, situated within an educational program in humanities with a focus on software studies. The course runs through 14 classes with 6 and 3 contact hours every week for Aesthetic Programming and Software Studies respectively. Though we offer 10 chapters here, in teaching practice[^teaching] it includes a 'pause week' to slow things down by not introducing new functions and syntaxes but more revisiting the past and discussing what might be Aesthetic Programming and how that links to their weekly practice and learning; we also have project weeks for preparation towards the final assessed submissions. Some flexibility is recommended if you are following this book for your curriculum and clearly the intention is for readers to adapt, modify and re-arrange contents. This is simply a template of sorts and we understand that this might not be suitable for different contexts and we hope to open up different ways of learning programming, and as such we encourage our readers to fork a copy and customize their own version for further adaptation. We take this to be recipe that can be shared and adapted, and the analogy to cooking is something we would wish to encourage, as we have tried in the book with concepts such as variables akin like kitchen containers, algorithms to recipes, and so on. We take inspiration here from our book designers Open Source Publishing who have extensive experience of running workshops with beginners, and using accessible metaphors from the kitchen: drawing together practices of coding and cooking, tasting and testing, to invite interpretation and further experimentation with ingredients: "In the OSP kitchen, source files = ingredients".[^kitchen]   

### The book object

Finally we stress that the book is not simply a physical object that you might be holding in your hands as you read these words, but a computational and networked object too, distributed across various other spaces and temporalities, and made available to both readers and writers alike. In saying this we make reference to Benjamin again, and his essay “The Author as Producer": “The reader is always prepared to become a writer, in the sense of being one who describes or prescribes. [...] And writing about work makes up part of the skill necessary to perform it. Authority to write is no longer founded in a specialist training but in a polytechnical one, and so becomes common property.”[^Benjamin2] (And interestingly, for Benjamin, cultural production requires a pedagogic function.)

This is exactly our point. The book expresses itself as a dynamic object not fixed in terms of attribution or commodity form. It follows that, although this preface is only the beginning of the book, there can be no end: the book is purposefully stuck in an endless loop of its own becoming.

## Notes

[^instructions]: The casual address "for dummies" could also be used but this carries the unfortunate connotation of learning disability.

[^useful]: Useful in the way we write software. Here we are making reference to nonstandard literacy, such as in the article: Marilyn M. Cooper, "Really Useful Knowledge: A Cultural Studies Agenda for Writing Centers", *The Writing Center Journal*, Vol. 14, No. 2 (Spring 1994), pp. 97-111, https://www.jstor.org/stable/43441948. 

[^ct]: Seymour Papert's influencial book *Mindstorms* in 1980 that brings computing into children's learning and introduces the term computuational thinking with the practice of constructing procedures with the early programming language Logo (which is not simply using software as tools), aiming to bridge the gap between mathematics, the culture of science and education as well as social critique. Donald Knuth who brings the concept of literacy more apparent through the book *Literate Programming* to consider a program as literature that involves seeing programming language as natural language for human readers, but it is more targeted for programmers. Revivial of this Computational Thinking to education is put forwarded by Jennette M. Wing in 2006 focuses on the formulation of algorithms to solve problems, and it is mainly adopted by STEM curriculum and apply in science related subjects such as biology and chemistry. In 2015, scholar Michael Mateas starts to think about introducing programming to arts and humanities, and emphasizes the need to connect with social and cultural issues through theoretical and philsophical considerations. In the field software studies, the notion of computational thinking is also picked up by scholars like David Berry, Matthew Fuller, Nick Montfort and lately Annette Vee. See Seymour, Papert. *Mindstorms; Children, Computers and Powerful Ideas.* New York: Basic Book, 1980; Knuth, Donald Ervin. *Literate Programming*. CSLI Lecture Notes, no. 27. Stanford, Calif.: Center for the Study of Language and Information, 1992; Jeannette M, Wing, ‘Computational Thinking’. *Commun. ACM* 49, no. 3 (March 2006): 33–35; Michael, Mateas, ‘Procedural Literacy: Educating the New Media Practitioner’, *Horizon* 13, no. 2 (1 June 2005): 101–11; David M, Berry, David M and Anders Fagerjord. *Digital humanities: knowledge and critique in a digital age*. John Wiley & Sons, 2017; Fuller, M, *How to be a Geek: Essays on the Culture of Software*, Cambridge: Polity Press, 2017; Nick, Montfort, *Exploratory programming for the arts and humanities*, MIT Press, 2016; Vee, A, *Coding Literacy: How Computer Programming Is Changing Writing*, MIT Press, 2017.

[^Fuller]: Software studies is an interdisciplinary research field, which studies software systems and their social and cultural effects, see Matthew Fuller, ed. *Software Studies: A Lexicon*, London: MIT Press, 2008.

[^Refs]: Here we are referring to John Maeda, *Creative Code: Aesthetics + Computation*, London: Thames & Hudson, 2004; Kylie A. Peppler and  Yasmin B. Kafai, “Creative coding: Programming for personal expression,” *The 8th International Conference on Computer Supported Collaborative Learning (CSCL)*, Vol. 2 (2009), pp. 76-78; Nick Montfort, *Exploratory Programming for the Arts and Humanities*. MIT Press, 2016; Noah Wardrip-Fruin, *Expressive Processing: Digital Fictions, Computer Games, and Software Studies*, The MIT Press, 2012. 

[^Magda]: Special mention should be extended to Magda Tyżlik-Carver and Christian Ulrik Andersen who have contributed to the teaching of these courses, as well as teaching assistants including Frederik Westergaard, Nils Rungholm Jensen, Tobias Stenberg, Malthe Stavning Erslev, Ann Karring, Simone Morrison, Nynne Lucca Christianen, Ester Marie Aagaard and Noah Aamund. We also thanks Theodoros Papatheodorou and Simon Katan from Goldsmiths, University of London for allowing us to observe their classes and to understand the pace and the sense making of teaching different syntax combinations in a classroom setting. Lastly thanks are also due to our artist friend Anders Visti who especially inspires us to include the example of Langton's Ant.

[^Ranciere]: Jacques Rancière, *The Politics of Aesthetics*, London: Continuum, 2006, that investigates what aesthetics and politics have in common: the delimitation of the thinkable and the unthinkable, the possible and the impossible, according to Rancière.

[^Jay]: The quote continues: "... which must be deciphered by means of critical analysis." (Martin Jay, *Aesthetic Theory*, 1996: 177).

[^Benjamin]: To quote Benjamin on this point: "The instant the criterion of authenticity ceases to be applicable to artistic production, the total function of art is reversed. Instead of being based on ritual, it begins to be based on another practice - politics." (ADD REF)

[^Adorno]: Adorno says it better: "A successful work of art, according to immanent criticism, is one that resolves objective contradictions in a spurious harmony, but one expresses the idea of harmony negatively by embodying the contradictions, pure and uncompromised, in its innermost structure" (Adorno, in *Prisms*, 1967: 32, also quoted in Jay, 1996: 179).

[^Chun]: Chun has studied both Systems Design Engineering and English Literature, which she combines and mutates in her current work, see https://en.wikipedia.org/wiki/Wendy_Hui_Kyong_Chun.

[^Williams]: Fuller, ed. *Software Studies*; Raymond Williams, *Keywords: A Vocabulary of Culture and Society*, London: Fontana, 1983; in 2005 Blackwell published *New Keywords: A Revised Vocabulary of Culture and Society*.

[^ss]: The project workshop description an be found archived at https://web.archive.org/web/20100327185154/http://pzwart.wdka.hro.nl/mdr/Seminars2/softstudworkshop.

[^Readme]: In particular we might cite the influence of the Readme festival... add more on this. Importantly here perhaps is to emphasise that the category of art in itself becomes inadequate to cover the kinds of creatives practices that have developed in the field. ADD REFS

[^codestudies]: The field Critical Code Studies (CCS) makes this explicit, promoting the examination of source code as a piece of cultural object for critical analysis. As Mark Marino suggests that CCS pays attention to code as textual materials and its main argument is that code itself can be considered as a "cultural text worthy of analysis and rich with possibilities for interpretation", and furthermore, code allows one to reflect "on the relations between the code itself, the coding architecture, the functioning of code, and specific programming choices or expressions, to that which it acts upon, outputs, processes, and represents". See Mark C. Marino, “[Critical Code Studies](https://electronicbookreview.com/essay/critical-code-studies/)”, *Electronic Book Review*, December 4, 2006; “Field Report for Critical Code Studies,” Computational Culture 4 (9th November 2014). Web. http://computationalculture.net/field-report-for-critical-code-studies-2014%e2%80%a8/; *Critical Code Studies*, MIT Press, 2020.

[^Cox]: Geoff Cox, "Generator: The Value of Software Art". In . Rugg & M. Sedgwick (Eds), *Issues in Curating Contemporary Art and Performance*. Bristol, Chicago: Intellect Lrd, 150.

[^OHP]: For more on Open Humanities Press, see https://openhumanitiespress.org/.

[^dok]: dokieli is a clientside editor for decentralised article publishing, annotations and social interactions, see https://dokie.li/.

[^devdocs]: See https://jupyter.org/ and https://devdocs.io/javascript/.

[^OSP]: For more on Open Source Publishing (OSP), see http://osp.kitchen/about. We are interested in this approach as it somewhat breaks down the divisions of labour associated with traditional publishing in which writing, editing, and designing, and the people that perform these tasks, are distanced from each other. 

[^Mackenzie]: See Adrian Mackenzie’s "Preface" to *Machine Learners: Archaeology of a Data Practice*, Cambridge, Mass.: MIT Press, 2017; and on GitHub at https://github.com/datapractice/machinelearners.

[^Git]: For more on this, see Matthew Fuller, Andrew Goffey, Adrian Mackenzie, Richard Mills and Stuart Sharples, "Big Diff, Granularity, Incoherence, and Production in the Github Software Repository", in Matthew Fuller, *How To Be a Geek: Essays on the Culture of Software*, Cambridge: Polity Press, 2017.

[^kitchen]: See OSP's home page and note the URL, http://osp.kitchen/.

[^Benjamin2]: Walter Benjamin, "The Author as Producer" [1935], quoted in Geoff Cox & Joasia Krysa, eds. *Engineering Culture: On the Author as (Digital) Producer*, New York, Autonomedia, 2005: 22.

[^diagram]: Morris, Stephen, and Orlena Gotel. "The Role of Flow Charts in the Early Automation of Applied Mathematics". *BSHM Bulletin: Journal of the British Society for the History of Mathematics* 26, no. 1 (March 2011): 44–52. https://doi.org/10.1080/17498430903449207.

[^agre]: Philip E. Agre, "Toward a critical technical practice: Lessons learned in trying to reform AI. In G. Bowker, L. Gasser, L. Star & B. Turner, (Eds.), *Bridging the great divide: Social science, technical systems, and cooperative work*. Erlbaum, 1997. 

[^teaching]: Here with the curriculum and messy notes for the course Aesthetic Programming in recent years: https://gitlab.com/siusoon/aesthetic-programming/-/tree/master/

[^readcode]: The field Critial Code Studies considers source code as cultural text for critical reading and interpretation beyond the understanding of how is code worked technically and functionally. See Mark C Marino, *Critical Code Studies*, MIT Press, 2020.